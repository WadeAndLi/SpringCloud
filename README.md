SpringCloud
1.Eureka: 实现服务器之间的通信，是一个注册中心，通过心跳来注册启动的服务器，可以配置默认注册的地点。 有Client 端和 server端, 可以配置端口号，client端可以注册到指定的服务端.

2.Ribbon 实现负载均衡，底层实用轮询的算法，通过累加计数来进行服务器调用。

3.hystrix 实现服务器降级和熔断，主要是三个状态 close，open, half open，用来进行服务器的熔断和再连。

4.feign 实现服务器端的端口隐藏和方法的注解，使用注解和接口的形式。 其中feign 已经集成了ribbon 所以不需要再引入.

5.Zull 实现微服务的网关作用，主要用来拦截请求，转发请求，实现负载均衡等作用, 路由制主要是使用Filter实现 Zull Filter中主要内置了4个类，用来进行请求拦截: filterType: 过滤类型： pre, routing, post, error filterOrder: 过滤顺序 shouldFilter: 要不要进行过滤 run: 过滤器逻辑

hystrix 的超时时常要是 ribborn 连接和读取超时时长的两倍多

当然 我们也不能只用一台Zuul服务器，当我们的系统需要做集群的时候，就需要在zull的外层再加上一次负载均衡 nginx, nginx可以利用ip漂移

Spring-cloud-config: 全局的配置中心，可以实现开发环境和生产环境的切换，可以和GIT 一起来使用

config server会先去拉取 git上的配置信息，然后每个微服务会去拉取config-server的信息
主动进行推送 Spring-cloud-bus 实现消息推送， 内部使用rabbitMQ，Kafka来进行实现的, 首先先去拉取git上的配置，然后通过spring cloud bus 去向每个server发送通知， 让服务器自动拉取配置, 不需要重启，可以自动生效。(需要配置) Spring-cloud-config 和 Spring-cloud-bus 是一套，用于配置动态更新.

Spring-cloud-hystrix-dashboard: 容错统计，形成一个图形化界面 Spring-cloud-sleuth: 链路追踪, 结合Zipkin

CDN服务， 将静态资源放到CDN服务器上，以前响应静态资源的时候，需要经过中间商然后进行转发，现在可以直接通过CDN获取我们的静态资源。

虚拟机
-. Nginx配置 1.使用了windows 自带的Hyper虚拟机，使用CentOS7操作系统. 2.如果想使用域名 而且不带端口访问前端页面，首先要做的就是使用nginx配置转发. 3.下载安装好虚拟机后，一定要记得使用静态IP，而且提前做好联网，不然会有很多问题. 4.使用fileZilla进行文件的上传和修改 5.下载好Nginx的安装包，然后进行解压和修改配置文件。 6.配置IP 和域名： 1）对于windows的配置，我们需要在host的文件下配置 域名和访问的IP (IP为虚拟机的IP， 可用Ip addr来查看) 2) nginx.conf 文件，配置端口号为80的拦截服务器 1.拦截我们前端静态页面的服务器 (端口名为manage.fly.com) 端口号 9001 2.拦截我们后端的服务器，拦截Zuul网关，(端口名为 api.fly.com) 端口号 10010 3.拦截的IP 注意填写成windows的IP，可以使用ipconfig来获取 3) 在虚拟机Ping一下看是否可以ping通 4) 开启前端静态页面的服务器 5) 输入域名 manage.fly.com

二. 配置Java通用异常类 2.配置通用异常类 1)首先 确定使用ResponseEntity<Classs<?>> 来做返回值 2)成功 直接可以返回 ResponseEntity.ok(body) 3)如果失败，自定义一个异常类，接受一个枚举(包括状态码和信息) 4)定义一个枚举 5)定义一个接收这个异常类的类，注解为 @ControllerAdvice， 里面定义一个方法做返回值，注解为@ExceptionHandler(异常类.class) 6)定义一个PO，返回标准的错误返回值 （可以通过枚举类来进行构造） 7)异常返回方法使用这个类做返回值的body.

三. FastDfs的配置 1.下载 fastDFS的压缩文件，下载fastDFS集成Nginx的文件 2. 解压文件，然后进入 tracker的文件中，进行配置路径。 3. 进入storaged文件中进行配置 4. 开启服务 (记得IP是虚拟机的IP） 5，测试 6. Java client端 1) 引入依赖 fastDFS的依赖 2) 使用依赖this.fileStorageClient.uploadFile (InputStream var1, long var2, String var4, Set var5)

四. 搭建Elacsticsearch微服务.
  1. 配置Eureka, 引入Feign的依赖 (配置要@EnableFeignClients)

五.引入Feign, feidn是一个实现客户端和服务端接口通信的技术,可以很好的规范REST风格的API编程规范，由于我们可能其他的服务也会使用相同的接口，我们通常建议将接口放入一个interface中，这样有利于代码的复用，我们可以把一些公共的服务接口放入到里面，然后如果其他的服务使用的时候，可以在自己的服务中注册feignclient然后集成这个接口就好了，这样很好的维持了代码的复用。


1. 如果Cookie被禁用了怎么办
  1) 可以提示用户cookie被禁用了，需要打开
  2) 可以把用户的信息放入 浏览器存储种 (sessionStorage), 然后每次请求都去拿token
  
2. 如果Cookie被盗用怎么办
  1) Cookie是无法被纂改的
  2) 加入ip来识别 (不推荐)
  3) 采用https协议，防止数据泄露

3. 如果微服务地址暴露怎么办
  1) 微服务的地址不会暴露，用户访问只是zuul,对外暴露的只是zuul
  2）可以使用微服务之间的授权，用一张表来获取每个微服务哪些服务可以调用
  
4. 如何让一个拦截器生效
  1) 编写一个拦截器，实现HandlerInterceptor.
  2) 实现里面的 pre 和 after方法 (用于方法执行之前和之后)
  3) 如何让这个拦截器生效 1.配置一个MVC config类, 实现WebMvcConfigurer
  4) 实现里面的 addInterceptor方法, 然后将我们自己写的拦截器添加到里面 (顺便添加一些拦截路径)
  
5. Spring + JWT + Oauth2 + spring security 实现登陆验证和授权
 Oauth2主要使用两种方式来进行单点登陆 
 1.使用授权的方式 具体的流程
  1) 用户登陆时跳转到授权页面 2) 用户点击确认授权，发送给服务端 3)服务端获取授权码，将授权码发送到自己的服务器
  4) 服务器接收到授权码，携带授权码发送申请令牌的请求 5) 授权服务器得到请求，发送令牌给自己的服务器 6)用户根据令牌去申请用户信息得到用户信息
 2.使用账号密码登陆的方式
  1) 用户输入账号密码，携带类型是password的信息去请求，服务器Oauth接收到请求，判断用户是否存在，如果存在，发送令牌到客户端
  2) 客户端以后的请求都会携带令牌，然后进行校验，判断令牌是否合法
  
 关于令牌的话，第二种方式我们使用的是JWT来生成一个令牌，使用的是公私钥的方式来进行加密
 JWT令牌 三部分 1.加密方式 2.请求体 3.证书 (包含前两部分，然后加密的，防止篡改),然后使用生成的私钥对令牌进行加密.
 客户端接收到令牌，使用公钥进行解密，获取用户信息，判断用户是否合法. 一般的话，我们会把令牌存在session storage里，然后每次请求的时候
 放在请求头.

6 分布式事务
 分布式系统有一个著名的理论CAP理论 一个分布式系统无法同时满足一致性
高可用性 分区容错性 所以我们一般追求的都是AP 然后追求最终的一致性
当我们一个操作需要同时对两个分布式系统的数据库进行操作的时候 我们需要保证
他们数据的强一致性 所以我们会加入分布式事务来处理这个东西
 分布式事务的解决方案
 1 两阶段提交事务 这个在mysql oracle中比较适用
实现方式：这里会引入一个事务协调器的概念 事务协调器可以将多个事务添加到列表中
然后当每个子事务完成的时候 会向事务协调器发送一个状态 并且会进入一个预提交的状态 然后事务协调器会去判断
是否所有的子事务都已经成功的执行了，如果都执行成功了 就会把他们全部提交 如果没有执行成功,协调器会去查看每个事务的redo
和undo日志 然后进行日志的回滚。所以两段式的提交都要有三个方法 叫做prepare 
commit rollback 三个方法 缺点：实现了一致性 牺牲了可用性 性能比较低 开发比较复杂 在并发的场景下不适合。

 2 补偿事务 和第一个方案不同 第一个方案是数据库的层面 来进行分布式事务 我们现在是在业务层面进行方案改进
实现方式 与两阶段提交类似 我们同样需要去写三个方法 try confirm cancel方法 
事务协调器先去执行所有事务的try方法 然后判断是否所有的子事务都有正确的应答 
如果所有的应答都是正确的 协调器就会去执行所有的confirm方法 进行提交 否则的话 就会去执行所有的cancel方法进行回滚

 3 本地消息表 + 异步确保的方式
这种方式是目前比较流行的一种方式 主要是通过向数据库中插入一些信息 使用MQ异步通信 使用schedule task进行定时任务的方式来
实现分布式的事务
具体实现方案: 1用户需要在分布式事务的开启端创建两张表 一张是历史记录表 用于存放记录 一张task表 用于存放schedule任务
用户进行自己的操作的时候 执行成功 向task表插入一条记录
2 用户使用MQ将历史表的信息发送到消费者 3消费者接收消息 执行业务操作 然后向数据库插曲一条类似的记录 id要相同 然后发送成功的消息到事务发起者
4 事务发起者接收到到消息 网历史表中插入一条数据 然后删除task表中的数据
Task定时任务一直循环执行 我们需要加入一些锁使他可以原子性操作 


  
